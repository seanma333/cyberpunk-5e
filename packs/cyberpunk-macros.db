{"name": "Reload", "type": "script", "scope": "global", "author": "35XmDJHnBMPCEkei", "img": "modules/cyberpunk-5e/assets/macro_icons/reload-gun-barrel.svg", "command": "const wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay));\n\nlet ammoData = {\n    \"bullets\": {\n        \"type\": \"consumable\",\n        \"img\":\"modules/cyberpunk-5e/assets/macro_icons/bullets.svg\",\n        \"system\": {\n            \"description\": {\"value\":\"<p>Standard ammunition used for guns of all varieties.</p>\"},\n            \"consumableType\": \"ammo\",\n            \"rarity\": \"common\"\n        }\n    },\n    \"shells\": {\n        \"type\": \"consumable\",\n        \"img\": \"modules/cyberpunk-5e/assets/macro_icons/shotgun-rounds.svg\",\n        \"system\": {\n            \"description\": {\"value\":\"<p>Standard ammunition used for shotguns.</p>\"},\n            \"consumableType\": \"ammo\",\n            \"rarity\": \"common\"\n        }\n    },\n    \"arrows\": {\n        \"type\": \"consumable\",\n        \"img\": \"modules/cyberpunk-5e/assets/macro_icons/arrows.svg\",\n        \"system\": {\n            \"description\": {\"value\": \"<p>Standard ammunition used for bows.</p>\"},\n            \"consumableType\": \"ammo\",\n            \"rarity\": \"common\"\n        }\n    },\n    \"bolts\": {\n        \"type\": \"consumable\",\n        \"img\": \"modules/cyberpunk-5e/assets/macro_icons/bolts.svg\",\n        \"system\": {\n            \"description\": {\"value\": \"<p>Standard ammunition used for crossbows.</p>\"},\n            \"consumableType\": \"ammo\",\n            \"rarity\": \"common\"\n        }\n    }\n}\n\nasync function getWeaponsToReload(actor) {\n    weapons = actor.items.filter(i => i.type === \"weapon\" && i.system.equipped && i.system.properties.rel && i.system.consume.type === \"ammo\");\n    weaponCapacities = []\n    weapons.forEach(w => {\n        if (!w.system.consume.target) {\n            weaponCapacities.push({\"id\": w.id, \"name\": w.name, \"ammo\": 0, \"capacity\": w.flags.cyberpunk5e.reload});\n            return;\n        }\n        ammo = actor.items.find(i => i.id === w.system.consume.target);\n        if (!ammo) {\n            weaponCapacities.push({\"id\": w.id, \"name\": w.name, \"ammo\": 0, \"capacity\": w.flags.cyberpunk5e.reload});\n        } else {\n            weaponCapacities.push({\"id\": w.id, \"name\": w.name, \"ammo\": ammo.system.quantity || 0, \"capacity\": w.flags.cyberpunk5e.reload});\n        }\n    });\n    return weaponCapacities.filter(wc => {\n        return wc.ammo < wc.capacity;\n    });\n}\n\nfunction getTotalAmmoQuantity(items, ammoType) {\n    return items.filter(i => {\n        if (!i.system.equipped) return false;\n        if (!i.flags.cyberpunk5e) return false;\n        // if (!i.flags.cyberpunk5e.type !== 'container') return false;\n        if (!i.flags.cyberpunk5e.capacity) return false;\n        if (!i.flags.cyberpunk5e.ammo_type === ammoType) return false;\n        return true;\n    }).map(i => {\n        var ammoItem = items.find(it => it.id === i.system.consume.target);\n        return ammoItem ? ammoItem.system.quantity : 0;\n    }).reduce((r, opt) => r + opt, 0)\n}\n\nfunction getAmmoQuantityToReload(items, weapon) {\n    var weaponStats = selectedWeapon.flags.cyberpunk5e;\n    var totalQty = getTotalAmmoQuantity(items, weaponStats.ammo_type);\n\n    var weaponAmmoItem = items.find(i => i.id === weapon.system.consume.target);\n    if (weaponAmmoItem) {\n        return Math.min(weaponStats.reload - weaponAmmoItem.system.quantity, totalQty);\n    } else {\n        return Math.min(weaponStats.reload, totalQty);\n    }\n}\n\nasync function reloadButton(html, token) {\n    let selectedWeaponId = html.find(\"[id=weapons]\")[0].value;\n    if (!selectedWeaponId) {\n        console.log(\"No weapon selected!\")\n        return;\n    }\n    selectedWeapon = token.actor.items.find(i => i.id === selectedWeaponId)\n    if (!selectedWeapon) {\n        console.error(\"Could not find weapon with selected token!\")\n        return;\n    }\n\n    // Check equipped ammo boxes to see how much ammo you can fill\n    var ammoQty = Math.max(getAmmoQuantityToReload(token.actor.items, selectedWeapon), 0)\n\n    // If no ammo target exists, create it.\n    targetAmmoId = selectedWeapon.system.consume.target;\n    targetAmmo = targetAmmoId ? token.actor.items.find(i => i.id === targetAmmoId) : null;\n    if (!targetAmmo) {\n        targetAmmo = await createAmmo(token.actor, selectedWeapon, ammoQty)\n        await selectedWeapon.update({\"system.consume.target\": targetAmmo.id})\n    } else {\n        weaponStats = selectedWeapon.flags.cyberpunk5e;\n        if (!weaponStats) return;\n        await targetAmmo.update({\"system.quantity\": targetAmmo.system.quantity + ammoQty})\n    }\n\n    // Remove ammoQty from ammo boxes\n    await removeAmmoQtyFromAmmoBoxes(token.actor.items, selectedWeapon.flags.cyberpunk5e.ammo_type, ammoQty);\n\n    // Output the reload to chat.\n    let content_html = `${token.actor.name} has reloaded ${selectedWeapon.name}!`;\n    ChatMessage.create({content: content_html});\n}\n\nasync function removeAmmoQtyFromAmmoBoxes(items, ammoType, ammoQty) {\n    var qtyToRemove = ammoQty\n    var ammoTargets = items.filter(i => {\n        if (!i.system.equipped) return false;\n        if (!i.flags.cyberpunk5e) return false;\n        // if (!i.flags.cyberpunk5e.type !== 'container') return false;\n        if (!i.flags.cyberpunk5e.capacity) return false;\n        if (i.flags.cyberpunk5e.ammo_type !== ammoType) return false;\n        return true;\n    }).map(a => {\n        return items.find(i => a.system.consume.target === i.id)\n    }).filter(a => {\n        if (!a) return false;\n        else return true;\n    }).sort((a, b) => {\n        return a.system.quantity < b.system.quantity\n    });\n\n    for (const ammoTarget of ammoTargets) {\n        if (qtyToRemove <= 0) return;\n        var ammoBoxQty = ammoTarget.system.quantity;\n        var qtyRemoved = Math.min(qtyToRemove, ammoBoxQty);\n        await ammoTarget.update({'system.quantity': ammoBoxQty - qtyRemoved})\n        qtyToRemove -= qtyRemoved;\n    };\n}\n\nasync function createAmmo(actor, weapon, ammoQty) {\n    weaponStats = weapon.flags.cyberpunk5e\n    weaponName = weapon.name.includes('[') ? weapon.name.substring(0, weapon.name.lastIndexOf('[')).trim() : weapon.name;\n    if (!weaponStats) return null;\n    ammoType = weaponStats.ammo_type\n    ammoName = ammoType[0].toUpperCase() + ammoType.slice(1)\n    ammoItem = ammoData[ammoType]\n    ammoItem.name = ammoName.concat(\" [\" + weaponName + \"]\")\n    ammoItem.system.quantity = ammoQty\n    items = await actor.createEmbeddedDocuments('Item', [ammoItem])\n    return items[0]\n}\n\nfunction updateAvailableLabel(html, items) {\n    label = html.find('[id=\"availableLabel\"]')[0];\n    selectedWeaponId = html.find(\"[id=weapons]\")[0].value;\n    if (!selectedWeaponId) {\n        label.innerHTML = '<p />';\n        return;\n    }\n    selectedWeapon = items.find(i => i.id === selectedWeaponId);\n    totalQty = getTotalAmmoQuantity(items, selectedWeapon.flags.cyberpunk5e.ammo_type)\n\n    label.innerHTML = `<p>${totalQty} ${selectedWeapon.flags.cyberpunk5e.ammo_type} available</p>`\n}\n\nasync function addUpdateHandlers(html, actor) {\n    html.find('[id=\"weapons\"]').on(\"change\", function(){updateAvailableLabel(html, actor.items)});\n}\n\nvar weapons = await getWeaponsToReload(token.actor)\n\nif (weapons.length > 0) {\n    let weaponOptions = weapons.map(w => \n        `<option value=${w.id}>${w.name} (${w.ammo})</option>`\n    ).reduce((r,opt) => r.concat(opt), '<option disabled value selected />')\n\n    let weaponSelector = `\n    <div>\n    <label>Select weapon:</label>\n    <select id=\"weapons\" name=\"weapons\">${weaponOptions}</select>\n    </div>`\n\n    let dialogHtml = `\n    <div>${weaponSelector}</div>\n    <div><label id=\"availableLabel\"><p/></label></div>\n    `;\n\n    let d = new Dialog({\n        title: \"Reload\",\n        content: dialogHtml,\n        buttons: {\n            reload: {\n                label: \"Reload\",\n                callback: (html) => reloadButton(html, token)\n            }\n        },\n        render: (html) => {\n            addUpdateHandlers(html, token.actor)\n        }\n    })\n    d.render(true)\n}", "folder": "xc47sRxy4heCqG6o", "sort": 0, "_id": "0xAinlH5ECtlpZXj", "_stats": {"systemId": "dnd5e", "systemVersion": "2.0.3", "coreVersion": "10.288", "createdTime": 1665463222565, "modifiedTime": 1668154860096, "lastModifiedBy": "35XmDJHnBMPCEkei"}, "flags": {"core": {"sourceId": "Compendium.cyberpunk-5e.cyberpunk-macros.ytNMnALEf7qZh0od"}}, "ownership": {"default": 0, "35XmDJHnBMPCEkei": 3}}
{"folder": "xc47sRxy4heCqG6o", "name": "Refill Ammo Container", "type": "script", "author": "35XmDJHnBMPCEkei", "img": "modules/cyberpunk-5e/assets/macro_icons/ammo-box.svg", "scope": "global", "command": "const wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay));\n\nlet ammoData = {\n    \"bullets\": {\n        \"type\": \"consumable\",\n        \"img\":\"modules/cyberpunk-5e/assets/macro_icons/bullets.svg\",\n        \"system\": {\n            \"description\": {\"value\":\"<p>Standard ammunition used for guns of all varieties.</p>\"},\n            \"consumableType\": \"ammo\",\n            \"rarity\": \"common\",\n            \"price\": 0.05\n        }\n    },\n    \"shells\": {\n        \"type\": \"consumable\",\n        \"img\": \"modules/cyberpunk-5e/assets/macro_icons/shotgun-rounds.svg\",\n        \"system\": {\n            \"description\": {\"value\":\"<p>Standard ammunition used for shotguns.</p>\"},\n            \"consumableType\": \"ammo\",\n            \"rarity\": \"common\",\n            \"price\": 0.05\n        }\n    },\n    \"arrows\": {\n        \"type\": \"consumable\",\n        \"img\": \"modules/cyberpunk-5e/assets/macro_icons/arrows.svg\",\n        \"system\": {\n            \"description\": {\"value\": \"<p>Standard ammunition used for bows.</p>\"},\n            \"consumableType\": \"ammo\",\n            \"rarity\": \"common\",\n            \"price\": 0.05\n        }\n    },\n    \"bolts\": {\n        \"type\": \"consumable\",\n        \"img\": \"modules/cyberpunk-5e/assets/macro_icons/bolts.svg\",\n        \"system\": {\n            \"description\": {\"value\": \"<p>Standard ammunition used for crossbows.</p>\"},\n            \"consumableType\": \"ammo\",\n            \"rarity\": \"common\",\n            \"price\": 0.05\n        }\n    }\n}\n\nfunction getAmmoContainerContents(container, items) {\n    if (!container.system.consume.target) return null;\n    contents = items.find(item => item.id === container.system.consume.target);\n    return contents;\n}\n\nfunction getAmmoContainerQty(container, items) {\n    contents = getAmmoContainerContents(container, items)\n    if (!contents) return 0;\n    return contents.system.quantity;\n}\n\nfunction getAmmoContainersToFill(actor) {\n    return actor.items.filter(i => {\n        if (!i.flags.cyberpunk5e) return false;\n        // if (!i.flags.cyberpunk5e.type !== 'container') return false;\n        if (!i.flags.cyberpunk5e.capacity) return false;\n        return getAmmoContainerQty(i, actor.items) < i.flags.cyberpunk5e.capacity;\n    });\n}\n\nasync function createAmmo(actor, container) {\n    containerProps = container.flags.cyberpunk5e;\n    if (!containerProps) return null;\n    ammoType = containerProps.ammo_type;\n    ammoName = ammoType[0].toUpperCase() + ammoType.slice(1);\n    ammoItem = ammoData[ammoType];\n    ammoItem.name = ammoName.concat(\" [\" + container.name + \"]\");\n    ammoItem.system.quantity = containerProps.capacity;\n    items = await actor.createEmbeddedDocuments('Item', [ammoItem]);\n    return items[0];\n}\n\nasync function refillButton(html, actor) {\n    var selectedContainerId = html.find('[id=containers]')[0].value;\n    var selectedContainer = actor.items.find(i => i.id === selectedContainerId);\n\n    var amountRefilled = selectedContainer.flags.cyberpunk5e.capacity;\n    var ammoItem = actor.items.find(i => i.id === selectedContainer.system.consume.target);\n    if (!ammoItem) {\n        ammoItem = await createAmmo(actor, selectedContainer);\n        await selectedContainer.update({'system.consume.target': ammoItem.id, 'system.consume.amount': 1})\n    } else {\n        amountRefilled = selectedContainer.flags.cyberpunk5e.capacity - ammoItem.system.quantity;\n        await ammoItem.update({'system.quantity': selectedContainer.flags.cyberpunk5e.capacity});\n    }\n    let content_html = `${actor.name} has filled ${selectedContainer.name}!`;\n    ChatMessage.create({content: content_html})\n}\n\nlet containers = getAmmoContainersToFill(token.actor);\nif (containers.length == 0) return;\n\nlet containerOptions = containers.map(c => {\n    var qty = getAmmoContainerQty(c, token.actor.items);\n    return `<option value=${c.id}>${c.name} [${qty}/${c.flags.cyberpunk5e.capacity}]</option>`;\n}).reduce((r,opt) => r.concat(opt), '<option disabled value selected />');\n\nlet containerSelector = `\n<div>\n    <label>Select container to refill:</label>\n    <select id=\"containers\" name=\"containers\">${containerOptions}</select>\n</div>`\nlet dialogHtml = `\n<div>${containerSelector}</div>\n`\n\nlet d = new Dialog({\n    title: \"Refill Ammo Container\",\n    content: dialogHtml,\n    buttons: {\n        reload: {\n            label: \"Refill\",\n            callback: (html) => refillButton(html, token.actor)\n        }\n    }\n});\nd.render(true);\n", "sort": 0, "_id": "bPoaDmulZfhdpeIX", "_stats": {"systemId": "dnd5e", "systemVersion": "2.0.3", "coreVersion": "10.288", "createdTime": 1668154888166, "modifiedTime": 1668154927737, "lastModifiedBy": "35XmDJHnBMPCEkei"}, "flags": {}, "ownership": {"default": 0, "35XmDJHnBMPCEkei": 3}}
{"name": "Modify Weapon", "type": "script", "author": "35XmDJHnBMPCEkei", "img": "modules/cyberpunk-5e/assets/macro_icons/gear-hammer.svg", "scope": "global", "command": "const wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay));\n\nfunction getWeaponsFromActor(actor) {\n    return actor.items.filter(i => {\n        if (i.type !== \"weapon\") return false;\n        if (!i.flags.hasOwnProperty(\"cyberpunk5e\")) return true;\n        return !i.flags.cyberpunk5e.hasOwnProperty(\"modification_props\");\n    });\n}\n\nfunction getModsFromActor(actor) {\n    return actor.items.filter(i => {\n        if (!i.flags.hasOwnProperty(\"cyberpunk5e\")) return false;\n        return i.flags.cyberpunk5e.hasOwnProperty(\"modification_props\");\n    }).sort((a,b) => {return a.name > b.name});\n}\n\nfunction getItemFromActor(actor, itemId) {\n    return actor.items.find(i => i.id === itemId)\n}\n\nfunction getTotalCP(currency) {\n    return 1000 * currency.pp + 100 * currency.gp + 50 * currency.ep + 10 * currency.sp + currency.cp\n}\n\nfunction subtractCP(currency, amount) {\n    cpToSubtract = amount\n    currencyToUse = {'pp': currency.pp, 'gp': currency.gp, 'ep': currency.ep, 'sp': currency.sp, 'cp': currency.cp}\n    \n    while (cpToSubtract >= 1000 && currencyToUse.pp > 0) {\n        currencyToUse.pp -= 1;\n        cpToSubtract -= 1000;\n    }\n\n    if (cpToSubtract > 0 && currencyToUse.pp > 0) {\n        currencyToUse.gp += 10 * currency.pp;\n        currency.pp = 0;\n    }\n    console.log(cpToSubtract)\n    \n    while (cpToSubtract >= 100 && currencyToUse.gp > 0) {\n        currencyToUse.gp -= 1;\n        cpToSubtract -= 100;\n    }\n    console.log(cpToSubtract)\n    \n    if (cpToSubtract > 0 && currencyToUse.gp > 0) {\n        currencyToUse.sp += 10 * currency.gp;\n        currency.gp = 0;\n    }\n    console.log(cpToSubtract)\n    \n    while (cpToSubtract >= 50 && currencyToUse.ep > 0) {\n        currencyToUse.ep -= 1;\n        cpToSubtract -= 50;\n    }\n    console.log(cpToSubtract)\n    \n    while (cpToSubtract >= 10 && currencyToUse.sp > 0) {\n        currencyToUse.sp -= 1;\n        cpToSubtract -= 10;\n    }\n    console.log(cpToSubtract)\n    \n    if (cpToSubtract > 0 && currencyToUse.sp > 0) {\n        currencyToUse.cp += 10 * currency.sp;\n        currency.sp = 0;\n    }\n    console.log(cpToSubtract)\n    \n    currencyToUse.cp -= cpToSubtract;\n    \n    return currencyToUse\n}\n\nfunction filterWeaponsForMod(mod, weapons) {\n    reqs = mod.flags.cyberpunk5e.modification_props.requirements\n    return weapons.filter(w => {\n        // Special case: Unarmed Strike\n        if (w.name.toLowerCase().includes('unarmed')) return false;\n    \n        // Cannot duplicate a modification\n        if (w.flags.cyberpunk5e.mods.some(m => m === mod.flags.cyberpunk5e.modification_props.prop_name)) return false;\n    \n        // Weapon Type\n        if (reqs.types.length > 0 && reqs.types.every(r => r !== w.system.weaponType)) return false;\n    \n        // Damage Type\n        if (reqs.dmg.length > 0 && reqs.dmg.every(r => {\n        return w.system.damage.parts.every(d => d[1] !== r)\n        })) return false;\n    \n        // Properties\n        if (Object.keys(reqs.properties).length > 0 && Object.entries(reqs.properties).some(\n        ([key, value]) => w.system.properties[key] !== value)) return false;\n\n        return true;\n    })\n}\n\nasync function addUpdateHandlers(html, actor) {\n      html.find('[name=\"modSelect\"]').on(\"change\", function(){updateWeaponSelect(html, actor)});\n      html.find('[name=\"weaponSelect\"]').on(\"change\", function(){updateCostToApply(html, actor)});\n}\n\nfunction updateWeaponSelect(html, actor) {\n    selectedModId = html.find('[name=\"modSelect\"]')[0].value;\n    selectedMod = getItemFromActor(actor, selectedModId);\n    \n    if (selectedMod.flags.cyberpunk5e.modification_props.applied) {\n        attachedWeapon = getItemFromActor(actor, selectedMod.flags.cyberpunk5e.modification_props.applied_to);\n    } else {\n        attachedWeapon = null;\n    }\n    \n    if (attachedWeapon) weaponsToSelect = [attachedWeapon];\n    else weaponsToSelect = filterWeaponsForMod(selectedMod, getWeaponsFromActor(actor))\n    \n    weaponOptions = weaponsToSelect.map(w => {\n        return `<option value=${w.id}>${w.name}</option>`\n    }).reduce((r,opt) => r.concat(opt), '<option disabled value selected />');\n    weaponSelect = html.find('[name=\"weaponSelect\"]')[0];\n    \n    if (weaponsToSelect.length > 0) weaponSelect.removeAttribute(\"disabled\");\n    else weaponSelect.setAttribute(\"disabled\", \"disabled\");\n    weaponSelect.innerHTML = weaponOptions;\n    \n    costToApplyElement = html.find('[id=\"modCost\"]')[0];\n    costToApplyElement.value = 0;\n    \n    warningLabel = html.find('[id=\"warningLabel\"]')[0];\n    warningLabel.innerHTML = '<p></p>'\n}\n\nfunction updateCostToApply(html, actor) {\n    selectedModId = html.find('[name=\"modSelect\"]')[0].value;\n    selectedMod = getItemFromActor(actor, selectedModId);\n    \n    selectedWeaponId = html.find('[name=\"weaponSelect\"]')[0].value;\n    selectedWeapon = getItemFromActor(actor, selectedWeaponId)\n    \n    costToApply = selectedMod.flags.cyberpunk5e.modification_props.price_mult * selectedWeapon.system.price\n    costToApplyElement = html.find('[id=\"modCost\"]')[0];\n    costToApplyElement.value = costToApply * 100;\n    \n    warningLabel = html.find('[id=\"warningLabel\"]')[0];\n    if (getTotalCP(actor.system.currency) < costToApply * 100) {\n        warningLabel.innerHTML = '<p>Not enough money to apply modification!</p>'\n    } else if (!selectedMod.flags.cyberpunk5e.modification_props.reversible) {\n        warningLabel.innerHTML = '<p>Warning: This modification is permanent!</p>'\n    } else {\n        warningLabel.innerHTML = '<p></p>'\n    }\n}\n\nasync function applyButton(html, actor) {\n    selectedModId = html.find('[name=\"modSelect\"]')[0].value;\n    selectedWeaponId = html.find('[name=\"weaponSelect\"]')[0].value;\n    \n    if (!selectedModId || !selectedWeaponId) return;\n    \n    selectedMod = getItemFromActor(actor, selectedModId);\n    selectedWeapon = getItemFromActor(actor, selectedWeaponId)\n    \n    costToApplyCP = parseInt(html.find('[id=\"modCost\"]')[0].value)\n    actorTotalCP = getTotalCP(actor.system.currency)\n      \n    if (costToApplyCP > actorTotalCP) {\n        ChatMessage.create({content: `${actor.name} does not have enough money to apply ${selectedMod.name} to ${selectedWeapon.name}!`});\n        return;\n    }\n    \n    await actor.update({'system.currency': subtractCP(actor.system.currency, costToApplyCP)})\n    \n    message = await applyModToWeapon(actor, selectedMod, selectedWeapon);\n    \n    ChatMessage.create({content: message})\n}\n\nasync function applyModToWeapon(actor, mod, weapon) {\n    mod_props = mod.flags.cyberpunk5e.modification_props\n    \n    weaponName = weapon.name.includes('[') ? weapon.name.substring(0, weapon.name.lastIndexOf('[')).trim() : weapon.name;\n    modName = mod.name.includes('[') ? mod.name.substring(0, mod.name.lastIndexOf('[')).trim() : mod.name;\n    \n    modUpdates = {}\n    if (mod_props.reversible && mod_props.applied) {\n        message = `${actor.name} detached ${modName} from ${weaponName}.`\n        effectsToApply = mod_props.reverse;\n        modUpdates[\"flags.cyberpunk5e.modification_props.applied\"] = false;\n        modUpdates[\"flags.cyberpunk5e.modification_props.applied_to\"] = null;\n        modUpdates[\"name\"] = modName;\n    } else {\n        if (mod_props.reversible) {\n            message = `${actor.name} attached ${modName} to ${weaponName}.`\n            modUpdates[\"flags.cyberpunk5e.modification_props.applied\"] = true;\n            modUpdates[\"flags.cyberpunk5e.modification_props.applied_to\"] = weapon.id;\n            modUpdates[\"name\"] = `${modName} [Attached to ${weaponName}]`\n        } else {\n            message = `${actor.name} installed ${modName} onto ${weaponName}.`;\n        }\n        effectsToApply = mod_props.effects;\n    }\n    \n    var weaponUpdates = {'flags.cyberpunk5e.mods': weapon.flags.cyberpunk5e.mods.concat([mod_props.prop_name])}\n    if (mod_props.reversible && weapon.flags.cyberpunk5e.mods.includes(mod_props.prop_name)) {\n        weaponUpdates['flags.cyberpunk5e.mods'] = weapon.flags.cyberpunk5e.mods.filter(p => p !== mod_props.prop_name)\n    }\n    \n    Object.entries(effectsToApply).forEach(([effect, data]) => {\n        data.forEach(([key, value]) => {\n        if (weaponUpdates.hasOwnProperty(key)) {\n            origValue = weaponUpdates[key]\n        } else {\n            path = key.split('.')\n            obj = weapon\n            while (path.length > 1) {\n            obj = obj[path.shift()]\n            }\n            origValue = obj[path.shift()];\n        }\n    \n        switch (effect) {\n            case 'update':\n            if (weaponUpdates.hasOwnProperty(key)) {\n                Object.assign(weaponUpdates[key], value);\n            } else {\n                weaponUpdates[key] = value\n            }\n            break;\n            case 'scale':\n            weaponUpdates[key] = origValue * value;\n            break;\n            case 'append':\n            weaponUpdates[key] = origValue.concat([value])\n            break;\n            default:\n            break;\n        }\n        })\n    })\n    \n    if (weaponUpdates['flags.cyberpunk5e.mods'].length > 0) {\n        weaponMods = weaponUpdates['flags.cyberpunk5e.mods'].sort((a, b) => a.localeCompare(b)).map(m => `${m[0].toUpperCase()}${m.slice(1)}`)\n        weaponUpdates['name'] = `${weaponName} [${weaponMods.join(', ')}]`;\n    } else {\n        weaponUpdates['name'] = weaponName;\n    }\n\n    \n    if (mod_props.reversible) {\n        await mod.update(modUpdates)\n    } else {\n        // Add the description of the mod to the weapon description.\n        description = mod.system.description.value\n        extracted = description.substring(description.lastIndexOf(\"</strong></p>\")+13).trim()\n        console.log(extracted)\n        weaponDescription = weapon.system.description.value\n        weaponDescription += `<p><strong>${mod.name}</strong></p>${extracted}`\n        console.log(weaponDescription)\n\n        weaponUpdates['system.description.value'] = weaponDescription;\n\n        if (mod.system.quantity > 1) {\n            await mod.update({'system.quantity': mod.system.quantity - 1})\n        } else {\n            await mod.delete()\n        }\n    }\n    \n    await weapon.update(weaponUpdates)\n    return message;\n}\n\n// Main Code\nvar mods = getModsFromActor(token.actor);\n\nif (mods.length == 0) return;\n\nvar modOptions = mods.map(m => {\n    if (!m.flags.cyberpunk5e.modification_props.reversible) {\n        return `<option value=${m.id}>Install ${m.name}</option>`;\n    }\n    \n    if (!m.flags.cyberpunk5e.modification_props.applied) {\n        return `<option value=${m.id}>Attach ${m.name}</option>`;\n    } else {\n        return `<option value=${m.id}>Detach ${m.name}</option>`;\n    }\n}).reduce((r,opt) => r.concat(opt), '<option disabled value selected />');\n\nvar dialogHtml = `\n<div>\n<label>Select weapon mod:</label>\n<select id=\"modSelect\" name=\"modSelect\">${modOptions}</select>\n</div>\n<div>\n<label>Select weapon to modify:</label>\n<select id=\"weaponSelect\" name=\"weaponSelect\" disabled></select>\n</div>\n<div>\n<label>Cost to Apply (CP):</label>\n<input type=\"number\" id=\"modCost\" name=\"modCost\" value=\"0\" readonly />\n</div>\n<div><label id=\"warningLabel\" style=\"color:red;font-weight:bold\"><p /></label></div>\n`\n\nvar d = new Dialog({\n    title: \"Modify Weapon\",\n    content: dialogHtml,\n    buttons: {\n        apply: {\n            label: \"Apply Mod\",\n            callback: (html) => applyButton(html, token.actor)\n        }\n    },\n    default: \"apply\",\n    render: (html) => {\n        addUpdateHandlers(html, token.actor)\n    }\n}).render(true)", "folder": "xc47sRxy4heCqG6o", "sort": 0, "_id": "vjOWnvOqmiaT3C5E", "_stats": {"systemId": "dnd5e", "systemVersion": "2.0.3", "coreVersion": "10.288", "createdTime": 1667782121600, "modifiedTime": 1668154860095, "lastModifiedBy": "35XmDJHnBMPCEkei"}, "flags": {"core": {"sourceId": "Compendium.cyberpunk-5e.cyberpunk-macros.t8NufKt9xNPScbgL"}}, "ownership": {"default": 0, "35XmDJHnBMPCEkei": 3}}
{"name": "Tool Check", "type": "script", "author": "35XmDJHnBMPCEkei", "img": "modules/cyberpunk-5e/assets/macro_icons/tinker.svg", "scope": "global", "command": "const wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay));\n\nasync function getToolNames(game, toolIds) {\n  let itemPack = game.packs.get(CONFIG.DND5E.sourcePacks.ITEMS);\n  let vehicles = CONFIG.DND5E.vehicleTypes;\n\n  let names = []\n  for (const [key, id] of Object.entries(toolIds)) {\n    if (vehicles[id]) {\n      names.push(vehicles[id]);\n      continue;\n    }\n    let itemId = CONFIG.DND5E.toolIds[id];\n    const itemDoc = await itemPack.getDocument(itemId);\n    if (itemDoc) {\n      names.push(itemDoc.name);\n    }\n  }\n  return names\n}\n\nasync function rollToolButton(html, adv, token) {\n  let selectedAbility = html.find(\"[id=ability]\")[0].value;\n  let expertise = html.find(\"[name=expertise]\")[0].checked;\n  let tool = html.find(\"[id=tools]\")[0].value;\n  switch(adv) {\n    case 'adv':\n      diceRoll = \"2d20kh1\";\n      break;\n    case 'disadv':\n      diceRoll = \"2d20kl1\";\n      break;\n    default:\n      diceRoll = \"1d20\";\n      break;\n  }\n  if (tool) {\n    rollToolCheck(token.actor, tool.replaceAll('-',' '), diceRoll, selectedAbility, expertise)\n  }\n}\n\nasync function rollToolCheck(actor, tool, diceRoll, ability, expertise) {\n  let actorData = actor.system\n  let mod = actorData.abilities[ability].mod;\n\n  let proficiency = expertise ? actorData.attributes.prof * 2 : actorData.attributes.prof;\n\n  let roll = await new Roll(`${diceRoll}+${proficiency}+${mod}`).roll();\n\n  // Imitate dice tooltip\n  console.log(roll.dice[0])\n  let result = 0;\n  let diceRollParts = roll.dice[0].results.map(d => {\n    if (d.active) {\n      result = d.result;\n    }\n    let maxmin = \"\"\n    if (d.result === 20) {\n      maxmin = \"max\"\n    } else if (d.result === 1) {\n      maxmin = \"min\"\n    }\n    return `<li class=\"roll die d20 ${d.discarded ? 'discarded': ''} ${maxmin}\">${d.result}</li>`\n  }).reduce((r, li) => r.concat(li), '')\n\n  let critfumble = \"\"\n  if (result === 20) {\n    critfumble = \"critical\";\n  } else if (result === 1) {\n    critfumble = \"fumble\";\n  }\n\n\n  let contentHtml = `\n    <header class=\"card-header flexrow\"><h3>${tool} [${ability.toUpperCase()}]${expertise ? ' (expertise)' : ''}</h3></header>\n    <div class=\"card-buttons\">\n      <div class=\"flexrow 1\">\n        <div class=\"dice-roll\">\n          <div class=\"dice-result\">\n            <div class=\"dice-formula\">${roll.formula}</div>\n            <div class=\"dice-tooltip\" style=\"display: none\">\n              <section class=\"tooltip-part\">\n                <div class=\"dice\">\n                  <ol class=\"dice-rolls\">${diceRollParts}</ol>\n                </div>\n              </section>\n            </div>\n            <h4 class=\"dice-total ${critfumble}\">${roll.total}</div>\n          </div>\n        </div>\n      </div>\n    </div>`\n\n  ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({token: actor}),\n    content: contentHtml\n  })\n}\n\nvar toolProf = token.actor.system.traits.toolProf;\nlet tools = await getToolNames(game, toolProf.value);\n\nif (toolProf.custom) {\n  tools = tools.concat(toolProf.custom.split(';'));\n}\n\nlet abilityScoreSelector = `\n<div>\n  <label>Select ability score:</label>\n  <select id=\"ability\" name=\"ability\">\n    <option value=\"str\">Strength</option>\n    <option value=\"dex\">Dexterity</option>\n    <option value=\"con\">Constitution</option>\n    <option value=\"int\" selected>Intelligence</option>\n    <option value=\"wis\">Wisdom</option>\n    <option value=\"cha\">Charisma</option>\n  </select>\n</div>\n`\n\nlet toolOptions = tools.map(tool => \n  `<option value=${tool.replaceAll(' ','-')}>${tool}</option>`\n).reduce((r,opt) => r.concat(opt), '<option disabled value selected />')\n\nlet toolSelector = `\n<div>\n<label>Select tool:</label>\n<select id=\"tools\" name=\"tools\">${toolOptions}</select>\n</div>`\n\nlet expertiseSelector = `\n<div><label>Expertise?</label><input name=\"expertise\" type=\"checkbox\"/></div>\n`\n\nlet dialogHtml = '<div>' + abilityScoreSelector.concat(toolSelector) + '</div>'.concat(expertiseSelector);\n\n\nlet d = new Dialog({\n  title: \"Tool Check\",\n  content: dialogHtml,\n  buttons: {\n    advantage: {\n      label: \"Advantage\",\n      callback: (html) => rollToolButton(html, \"adv\", token)\n    },\n    normal: {\n      label: \"Normal\",\n      callback: (html) => rollToolButton(html, \"norm\", token)\n    },\n    disadvantage: {\n      label: \"Disadvantage\",\n      callback: (html) => rollToolButton(html, \"disadv\", token)\n    },\n  }\n})\nd.render(true)", "folder": "xc47sRxy4heCqG6o", "sort": 0, "_id": "zFuszawcFuDDNJx8", "_stats": {"systemId": "dnd5e", "systemVersion": "2.0.3", "coreVersion": "10.288", "createdTime": 1665462898401, "modifiedTime": 1668154860096, "lastModifiedBy": "35XmDJHnBMPCEkei"}, "flags": {"core": {"sourceId": "Compendium.cyberpunk-5e.cyberpunk-macros-custom.ziJD47iwx3Yo7BKn"}}, "ownership": {"default": 0, "35XmDJHnBMPCEkei": 3}}
